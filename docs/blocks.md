# Blocks

* /mii/web/Blocks
* /mii/web/Block

Blocks – это система организации шаблонов и ресурсов проекта (всего того, что относится к frontend).
Шаблоны представляют собой традиционные php—шаблоны. Под ресурсами в данном случае понимаются js, css файлы (для них
специальная обработка) и любые другие файлы (изображения, swf, etc).
В основе лежит идея, что интерфейс любого сайта можно представить в виде набора независимых блоков.
Blocks это:
1. соглашение об именовании и организации файлов.
2. традиционные php шаблоны
3. механизм автоматической сборки ресурсов

Как выглядит традиционные системы шаблонов и организации ресурсов в php—проектах? Ну, наверное, как-то так:
```
$assets->add_css('path/to/file.css');
$assets->add_css('path/to/another/file.css');
$assets->add_js('path/to/script.js');

$template = new Template('path/to/template');
$template->set(something);
$template->render()
```

Единственная связь ресурсов с шаблонами в этом случае — это разве что вызов ```$assets->render_includes()``` где-нибудь
в теле шаблона.

Blocks схож с подобными системами в том смысле, что он тоже управляет ресурсами в реал-тайм. Список используемых в текущий
момент ресурсов строится в реальном времени.

Ключевое отличие Blocks — наличие методологии.

#### Библиотеки блоков

По умолчанию все блоки лежат в директории app/blocks. И это является дефолтной библиотекой блоков.
Библиотека может обладать любым путем (т.е. не обязательно директория blocks. Можно назвать bloxs и положить куда угодно).
Библиотек может быть больше, чем одна. В таком случае нужный блок ищется по очереди в каждой библиотеке блоков (в порядке их подключения).
*Так например, можно добавить библиотеку для мобильной версии сайта и поставить ее первой. И в случае, если содержимое шаблона 
едино для обоих версий, менять только css. В таком случае система возьмет css файл блока в первой библиотеке, а шаблон из следующей*


#### Именование блоков
Обращение к блоку производится по его имени. Блоки могут быть вложены в другие, что отражается в их имени.
К примеру, блок foo_bar вложен в блок foo. На уровневой файловой системы символ подчеркивания заменяется слэшем.
Поэтому директория блока foo_bar будет `/foo/bar/`
При этом полный путь к файлу шаблонов будет таким: `/foo/bar/foo_bar.php`, к файлу стилей `/foo/bar/foo_bar.css`, к js файлу,
соответственно, `/foo/bar/foo_bar.js`.

Понятие «вложенный блок» довольно условно. Кроме физического расположения такие блоки могут быть ничем больше не связаны
(Но, на практике, конечно, вложенные блоки всегда логически/семантически связаны с родительским блоком).

Стоит избегать излишней вложенности. Нет ничего страшного в определенном упрощении структуры. Вложенность больше 3х уровней приводит к
не слишком удобным длинным идентификаторам.


#### Блок и работа с ним

Обращение к блоку осуществляется следующим образом: ```Blocks::get(имя блока);``` (а точнее: ```Mii:$app->blocks()->get(имя блока)```), 
но на практике всегда используется краткий алиас ```block(имя блока);```

Основные методы работы с блоком:

- ```set($name, $value)``` установка переменных блока. Может быть передана пара имя-значения или ассоциативный массив
- ```bind($name, $value)``` аналог set, но установливается не значение, а ссылка
- ```get($name)``` получение значения переменной
- ```render($force = false)``` рендеринг шаблона. По умолчанию шаблон не будет отрендерен, если до этого не была установлена ни одна переменная. Флаг force включает рендеринг в любом случае.
- ```depends([dep1, dep2, ...])``` список зависимых блоков, которые необходимо подключить

Также допустима установка/получение переменных прямым обращением:
```
block('имя блока')->foo = 'bar';
echo block('имя блока')->foo;
```
Этот код выведет строку ```bar```

Код ```echo block('имя блока');``` эквивалентен ```echo block('имя блока')->render();```

#### CSS, js

Каждый блок может содержать css и js файлы. При этом, правильным способом работы является использование уникальных имен классов/переменных.
Название всех css-классов лучше начинать с имени самого блока. Код в js файлах — оборачивать в объект с именем блока.
(Впрочем, это лишь соглашение. Никаких физических ограничений на содержимое нет).

css и js файлы будут автоматически подключены к проекту при любом вызове блока в коде (даже в том случае, если он фактически не рендерится).

Файлы автоматически копируются в директорию /assets. В зависимости от настроек или по отдельности, или склеиваются в один файл (по имени блока).

Конечно же, файлы не копируются каждый раз. Осуществляется или проверка даты изменения файла (если хотя бы один файл в одном из блоков изменен позже,
чем итоговый файл, то произойдет пересборка).
Есть возможность заморозить процесс сборки полностью (опция frozen = true).

#### Ручная сборка

В целях оптимизации, есть возможность отключить автоматическую сборку полностью.
Для этого нужно сформировать массив соответствий:

имя основного блока -> список зависимых блоков

По этому массиву билдер автоматически соберет все ресурсы. И в дальнейшем, при выводе основного блока, будет подключать
к странице нужные файлы ресурсов.


#### Подключение css/js

Получить список текущих подключенных css и js файлов можно вызовом ````Blocks::instance()->render_assets()````
Данная функция возвращает список script и style тэгов для подключения соответствующих файлов.
Обычно используется в базовом блоке index:

````php
<head>
    <?php echo Blocks::instance()->render_assets(); ?>
    или просто:
    <?php echo Blocks::instance(); ?>
</head>
````

Для корректной работы необходимо, что бы вызов render_assets() был после всех обращений к другим блокам. Обычно это реализуется выводом базового блока
index в методе after и отсутствием прямых обращений к другим блокам в самом index.


#### assets
В директории любого блока может находится поддиректория assets. Содержимое этой директории без изменений 
копируется в директорию /assets/имя блока/ в публичной части сайта (или другое место. задается переменной assets_dir в конфиге).


#### Конфигурация

```php

    'blocks' => [
        'libraries' => [   // пути к библиотекам блоков
            __DIR__.'/blocks/' // по умолчанию APP_PATH.'/blocks';
        ],
        'merge' => true, // склеивать ли css (или js) файлы между собой или нет
        'frozen_mode' => false, // если включить, то никакого копирования, слияния файлов, проверки дат и т.п. происходить не будет  
        'assets_dir' => PUB_PATH.'/assets', // абсолютный путь к директории, куда копируются обработанные ресурсы
        'assets_pub_dir' => '/assets' // url-путь относительно корня или полный url (обычно, если выносим ресурсы на поддомен)
        'depends_map' => null // ассоциативный массив зависимостей всех блоков. необходим для корректной работы в frozen_mode
    ],
```    






